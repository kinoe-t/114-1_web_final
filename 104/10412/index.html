<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<title>å°ç²¾éˆä¸‰å±€æŒ‘æˆ°</title>
<style>
  body {
    margin: 0;
    background: #000;
    color: #fff;
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  h1 { margin: 10px; }
  canvas {
    background: #111;
    border: 2px solid #555;
  }
</style>
</head>
<body>
<h1>å°ç²¾éˆä¸‰å±€æŒ‘æˆ°</h1>
<canvas id="game" width="400" height="400"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const gridSize = 20;
const cols = canvas.width / gridSize;
const rows = canvas.height / gridSize;

let round = 1;            // ç›®å‰å±€æ•¸ï¼ˆæœ€å¤š 3 å±€ï¼‰
let pacmanLives = 1;      // å°ç²¾éˆåªæœ‰ 1 éš»
let gameOver = false;

let pacman = { x: 1, y: 1 };
let ghosts = [];
let foods = [];

function initFoods() {
  if (foods.length > 0) return; // é£Ÿç‰©åªåœ¨ç¬¬ä¸€æ¬¡ç”¢ç”Ÿ
  for (let i = 0; i < 40; i++) {
    foods.push({
      x: Math.floor(Math.random() * cols),
      y: Math.floor(Math.random() * rows),
      eaten: false
    });
  }
}

function initPacman() {
  pacman.x = 1;
  pacman.y = 1;
}

function initGhosts() {
  ghosts = [];
  while (ghosts.length < 7) {
    const gx = Math.floor(Math.random() * cols);
    const gy = Math.floor(Math.random() * rows);
    // é¿å…å¹½éˆä¸€é–‹å§‹å°±ç”Ÿæˆåœ¨å°ç²¾éˆèº«ä¸Šï¼Œå°è‡´ç«‹åˆ» Game Over
    if (gx !== pacman.x || gy !== pacman.y) {
      ghosts.push({ x: gx, y: gy });
    }
  }
}

function startRound() {
  initPacman();
  initGhosts();
  initFoods();
}

function drawPacman() {
  ctx.fillStyle = 'yellow';
  ctx.beginPath();
  ctx.arc(
    pacman.x * gridSize + gridSize / 2,
    pacman.y * gridSize + gridSize / 2,
    gridSize / 2 - 2,
    0,
    Math.PI * 2
  );
  ctx.fill();
}

function drawGhosts() {
  ctx.fillStyle = 'red';
  ghosts.forEach(g => {
    ctx.fillRect(
      g.x * gridSize + 2,
      g.y * gridSize + 2,
      gridSize - 4,


      gridSize - 4
    );
  });
}

function drawFoods() {
  ctx.fillStyle = 'white';
  foods.forEach(f => {
    if (!f.eaten) {
      ctx.beginPath();
      ctx.arc(
        f.x * gridSize + gridSize / 2,
        f.y * gridSize + gridSize / 2,
        3,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }
  });
}

function moveGhosts() {
  ghosts.forEach(g => {
    const dir = Math.floor(Math.random() * 4); // éš¨æ©Ÿæ–¹å‘
    if (dir === 0) g.x++;
    if (dir === 1) g.x--;
    if (dir === 2) g.y++;
    if (dir === 3) g.y--;
    g.x = (g.x + cols) % cols; // é‚Šç•Œå¾ªç’°
    g.y = (g.y + rows) % rows;
  });
}

function checkCollisions() {
  // åƒåˆ°é£Ÿç‰©
  foods.forEach(f => {
    if (!f.eaten && f.x === pacman.x && f.y === pacman.y) {
      f.eaten = true;
    }
  });

  // ç¢°åˆ°å¹½éˆ
  for (let g of ghosts) {
    if (g.x === pacman.x && g.y === pacman.y) {
      pacmanLives--;
      round++;

      if (pacmanLives <= 0 || round > 3) {
        gameOver = true;
      } else {
        startRound();
      }
      return;
    }
  }

  // ä¸‰å±€å…§ææ—©åƒå®Œå…¨éƒ¨é£Ÿç‰©
  if (foods.every(f => f.eaten)) {
    gameOver = true;
  }
}

function drawEndScreen() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#fff';
  ctx.font = '30px Arial';
  ctx.textAlign = 'center';
  ctx.fillText(
    foods.every(f => f.eaten) ? 'ğŸ†ğŸ† å‹ åˆ© ğŸ†ğŸ†' : 'ğŸ‘ å¤± æ•— ğŸ‘',
    canvas.width / 2,
    canvas.height / 2
  );
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawFoods();
  drawPacman();
  drawGhosts();

  ctx.fillStyle = '#0f0';
  ctx.font = '14px Arial';
  ctx.fillText(`ç¬¬ ${round} å±€ / æœ€å¤š 3 å±€`, 10, 15);
}

function update() {
  if (gameOver) {
    drawEndScreen();
    return;
  }
  moveGhosts();
  checkCollisions();
  draw();
}

window.addEventListener('keydown', e => {
  if (gameOver) return;
  if (e.key === 'ArrowUp') pacman.y--;
  if (e.key === 'ArrowDown') pacman.y++;
  if (e.key === 'ArrowLeft') pacman.x--;
  if (e.key === 'ArrowRight') pacman.x++;

  pacman.x = (pacman.x + cols) % cols;
  pacman.y = (pacman.y + rows) % rows;
});

startRound();
// å…ˆç•«ä¸€æ¬¡ç•«é¢ï¼Œé¿å…åˆå§‹é»‘ç•«é¢
draw();
setInterval(update, 300);
</script>
</body>
</html>
