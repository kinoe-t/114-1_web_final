<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Toad's Long Adventure</title>
<style>
    body { 
        margin: 0; 
        background: #202020; 
        overflow: hidden; 
        font-family: 'Microsoft JhengHei', 'Segoe UI', sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        touch-action: none;
    }
    
    #game-container {
        position: relative;
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
        background: #5c94fc;
        max-width: 100%;
        max-height: 100%;
    }

    canvas { 
        display: block; 
        image-rendering: pixelated; 
        max-width: 100%;
        cursor: pointer;
    }

    .controls {
        position: absolute;
        bottom: 20px;
        width: 100%;
        display: none;
        pointer-events: none;
        justify-content: space-between;
        padding: 0 20px;
        box-sizing: border-box;
    }

    .d-pad, .action-btn {
        pointer-events: auto;
        display: flex;
        gap: 15px;
    }

    .btn {
        width: 65px;
        height: 65px;
        background: rgba(255, 255, 255, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.6);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 24px;
        user-select: none;
        -webkit-user-select: none;
        touch-action: manipulation;
        font-weight: bold;
    }

    .btn:active {
        background: rgba(255, 255, 255, 0.6);
        transform: scale(0.95);
    }

    @media (max-width: 1024px) {
        .controls { display: flex; }
    }
</style>
</head>
<body>

<div id="game-container">
    <canvas id="game" width="800" height="448"></canvas>
    
    <div class="controls">
        <div class="d-pad">
            <div class="btn" id="btn-left">‚Üê</div>
            <div class="btn" id="btn-right">‚Üí</div>
        </div>
        <div class="action-btn">
            <div class="btn" id="btn-jump">Ë∑≥</div>
        </div>
    </div>
</div>

<script>
window.addEventListener('load', function() {
    try {
        initGame();
        window.focus();
        document.getElementById('game').focus();
    } catch (e) {
        console.error("Game Init Error:", e);
    }
});

let c, ctx;
let GRAVITY, GROUND_Y, camX, gameState;
let player, blocks, particles, enemies, clouds, flag, pits;
let keys = {};

function initGame() {
    c = document.getElementById("game");
    ctx = c.getContext("2d");

    // ÈªûÊìäËÅöÁÑ¶
    c.addEventListener('mousedown', () => window.focus());
    c.addEventListener('touchstart', () => window.focus());

    function resize() {
        if(!c) return;
        let scale = Math.min(window.innerWidth / 800, window.innerHeight / 448);
        c.style.width = (800 * scale) + "px";
        c.style.height = (448 * scale) + "px";
    }
    window.addEventListener('resize', resize);
    resize();

    // ========== ÂèÉÊï∏Ë®≠ÂÆö ==========
    GRAVITY = 0.8;
    GROUND_Y = 380;
    camX = 0;
    gameState = "playing";

    player = {
        x: 100, y: GROUND_Y - 48, w: 32, h: 48,
        vx: 0, vy: 0,
        onGround: false,
        crouch: false,
        facingRight: true,
        life: 3,
        coins: 0,
        score: 0,
        invincible: 0
    };

    // ========== ÈóúÂç°Ë®≠Ë®à (Âä†Èï∑Áâà) ==========
    
    // 1. ÂÆöÁæ©ÂùëÊ¥û (X ÂçÄÈñì)
    pits = [
        {start: 1100, end: 1250}, // Á¨¨‰∏ÄÂÄãÂùë
        {start: 2200, end: 2300}  // Á¨¨‰∫åÂÄãÂùë
    ];

    blocks = [];
    enemies = [];

    // ËºîÂä©ÂáΩÊï∏ÔºöÂª∫Á´ã‰∏ÄÊéíÁ£öÂ°ä
    function createRow(x, y, count, type="brick") {
        for(let i=0; i<count; i++) {
            blocks.push({x: x + i*32, y: y, type: type, used: false});
        }
    }

    // ËºîÂä©ÂáΩÊï∏ÔºöÂª∫Á´ãÈöéÊ¢Ø
    function createStairs(x, y, height, dir=1) {
        for(let i=0; i<height; i++) {
            for(let j=0; j<=i; j++) {
                let bx = dir === 1 ? x + i*32 : x + (height-1)*32 - i*32;
                blocks.push({x: bx, y: y - j*32, type: "brick"});
            }
        }
    }

    // --- ÂçÄÂüü 1: Ëµ∑ÈªûËàáÂü∫Á§éÁ∑¥Áøí ---
    createRow(300, 250, 1, "question");
    createRow(432, 280, 1, "brick");
    createRow(464, 280, 1, "question");
    createRow(496, 280, 1, "brick");
    createRow(400, 150, 3, "brick"); // È´òËôï
    createRow(432, 150, 1, "question"); 

    enemies.push({x: 600, y: GROUND_Y - 32, w: 32, h: 32, vx: -2, alive: true});
    enemies.push({x: 750, y: GROUND_Y - 32, w: 32, h: 32, vx: -2, alive: true});

    // --- ÂçÄÂüü 2: ÂùëÊ¥ûÊåëÊà∞ ---
    // ÂùëÊ¥ûÂâçÁöÑÈ´òÂè∞
    createRow(950, 220, 3, "brick");
    createRow(1046, 120, 1, "question"); // Ë™òÈ§å
    
    // ÂùëÊ¥ûÂ∞çÈù¢ÁöÑÊïµ‰∫∫
    enemies.push({x: 1300, y: GROUND_Y - 32, w: 32, h: 32, vx: -2, alive: true});
    enemies.push({x: 1350, y: GROUND_Y - 32, w: 32, h: 32, vx: -2, alive: true});

    // --- ÂçÄÂüü 3: Á£öÂ°äËø∑ÂÆÆ ---
    createRow(1500, 280, 2, "brick");
    createRow(1600, 200, 5, "brick"); // Ê©ã
    createRow(1664, 200, 1, "question");
    
    enemies.push({x: 1650, y: 168, w: 32, h: 32, vx: 2, alive: true}); // Ê©ã‰∏äÁöÑÊïµ‰∫∫
    enemies.push({x: 1800, y: GROUND_Y - 32, w: 32, h: 32, vx: -2, alive: true});

    // --- ÂçÄÂüü 4: Â§ßÈöéÊ¢Ø ---
    createStairs(2400, GROUND_Y, 5, 1); // ‰∏äÂù°
    createRow(2600, GROUND_Y - 128, 2, "brick"); // ÈÄ£Êé•
    createStairs(2700, GROUND_Y, 5, -1); // ‰∏ãÂù°

    // --- ÂçÄÂüü 5: ÁµÇÈªûÂâçÁöÑÊïµ‰∫∫Â§ßËªç ---
    for(let i=0; i<5; i++) {
        enemies.push({x: 2900 + i*60, y: GROUND_Y - 32, w: 32, h: 32, vx: -2 - (i%2), alive: true});
    }
    createRow(3000, 250, 1, "question");

    // ÁµÇÈªû
    flag = {x: 3400, y: GROUND_Y - 280};

    // ËÉåÊôØÈõ≤Êúµ
    clouds = [];
    for(let i=0; i<20; i++) {
        clouds.push({
            x: Math.random() * 4000,
            y: 30 + Math.random() * 150,
            s: 0.5 + Math.random() * 1
        });
    }

    particles = [];
    
    // ÈçµÁõ§ËàáËß∏ÊéßË®≠ÂÆö
    setupControls();

    loop();
}

function setupControls() {
    keys = {ArrowLeft: false, ArrowRight: false, ArrowUp: false, ArrowDown: false, Space: false};

    window.addEventListener('keydown', e => {
        if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
        keys[e.code] = true;
        if(e.code === "Space") keys.ArrowUp = true;
    });

    window.addEventListener('keyup', e => {
        keys[e.code] = false;
        if(e.code === "Space") keys.ArrowUp = false;
    });

    const btnLeft = document.getElementById('btn-left');
    const btnRight = document.getElementById('btn-right');
    const btnJump = document.getElementById('btn-jump');

    if(btnLeft) {
        const addTouch = (elem, code) => {
            elem.addEventListener('touchstart', (e) => { e.preventDefault(); keys[code] = true; }, {passive: false});
            elem.addEventListener('touchend', (e) => { e.preventDefault(); keys[code] = false; }, {passive: false});
            elem.addEventListener('mousedown', (e) => { e.preventDefault(); keys[code] = true; });
            elem.addEventListener('mouseup', (e) => { e.preventDefault(); keys[code] = false; });
            elem.addEventListener('mouseleave', (e) => { e.preventDefault(); keys[code] = false; });
        };
        addTouch(btnLeft, 'ArrowLeft');
        addTouch(btnRight, 'ArrowRight');
        addTouch(btnJump, 'ArrowUp');
    }
}

function loop() {
    try {
        update();
        draw();
        requestAnimationFrame(loop);
    } catch (e) {
        console.error(e);
    }
}

function update() {
    if (gameState !== "playing") {
        if (keys.ArrowUp || keys.Space || keys.ArrowRight) {
             if(gameState === "gameover" || gameState === "won") location.reload();
        }
        return;
    }

    // --- Áé©ÂÆ∂ÁßªÂãï ---
    player.vx = 0;
    player.crouch = false;

    if (keys.ArrowLeft) { player.vx = -5; player.facingRight = false; }
    if (keys.ArrowRight) { player.vx = 5; player.facingRight = true; }
    if (keys.ArrowDown && player.onGround) { player.crouch = true; player.vx = 0; }
    if (keys.ArrowUp && player.onGround) { player.vy = -16; player.onGround = false; }

    player.vy += GRAVITY;
    player.x += player.vx;
    player.y += player.vy;

    // --- Âú∞Èù¢ËàáÂùëÊ¥ûÂÅµÊ∏¨ ---
    let overPit = false;
    for(let pit of pits) {
        if(player.x + 10 > pit.start && player.x + player.w - 10 < pit.end) {
            overPit = true;
            break;
        }
    }

    if (!overPit && player.y >= GROUND_Y - player.h) {
        player.y = GROUND_Y - player.h;
        player.vy = 0;
        player.onGround = true;
    } else {
        player.onGround = false;
    }

    // ÊéâËêΩÊ≠ª‰∫°Âà§ÂÆö
    if (player.y > 600) {
        player.life = 0;
        gameState = "gameover";
    }

    if (player.x < 0) player.x = 0;

    // Èè°È†≠Ë∑üÈö®
    let targetCamX = player.x - 200;
    targetCamX = Math.max(0, Math.min(targetCamX, flag.x - 400)); // ÈôêÂà∂Èè°È†≠‰∏çË∂ÖÈÅéÁµÇÈªûÂ§™Â§ö
    camX += (targetCamX - camX) * 0.1;

    // Á£öÂ°äÁ¢∞Êíû
    checkBlockCollisions();

    // Á≤íÂ≠ê
    particles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy; p.vy += GRAVITY * 0.5;
        p.life--;
        if(p.life <= 0) particles.splice(i, 1);
    });

    // Êïµ‰∫∫
    enemies.forEach(e => {
        if (!e.alive) return;
        
        // Êïµ‰∫∫ÈáçÂäõ (Â¶ÇÊûúÂú®Á©∫‰∏≠)
        let enemyOnGround = false;
        // Á∞°ÂñÆÂú∞Èù¢Ê™¢Êü•
        let eOverPit = false;
        for(let pit of pits) {
            if(e.x + e.w/2 > pit.start && e.x + e.w/2 < pit.end) {
                eOverPit = true; break;
            }
        }
        
        if(!eOverPit && e.y >= GROUND_Y - e.h) {
            e.y = GROUND_Y - e.h;
            enemyOnGround = true;
        } else {
            // Ê™¢Êü•ÊòØÂê¶Âú®Á£öÂ°ä‰∏ä
            blocks.forEach(b => {
                 if(!b.broken && e.x + e.w > b.x && e.x < b.x + 32 && e.y + e.h >= b.y && e.y + e.h < b.y + 32) {
                     e.y = b.y - e.h;
                     enemyOnGround = true;
                 }
            });
        }

        if(!enemyOnGround) e.y += 4; // ÊéâËêΩÈÄüÂ∫¶
        e.x += e.vx;

        // Á∞°ÂñÆÂõûÈ†≠ AI (Á®çÂæÆËÅ∞Êòé‰∏ÄÈªûÈªû)
        if(e.x < camX - 100 && e.vx < 0) e.alive = false; // Ë∂ÖÂá∫Áï´Èù¢Â§™ÈÅ†ÁßªÈô§

        if (hit(player, e)) {
            if (player.vy > 0 && player.y < e.y - e.h/2) {
                e.alive = false;
                player.vy = -10;
                player.score += 200;
                spawnParticle(e.x + e.w/2, e.y, "text", "200");
            } else if (player.invincible <= 0) {
                player.life--;
                player.invincible = 60;
                if (player.life <= 0) gameState = "gameover";
            }
        }
    });

    if (player.invincible > 0) player.invincible--;
    if (player.x > flag.x) gameState = "won";
}

function checkBlockCollisions() {
    blocks.forEach(b => {
        if (b.broken) return;
        
        if (player.x + player.w > b.x && player.x < b.x + 32) {
             // È†ÇÁ£öÂ°ä
             if (player.vy < 0 && player.y <= b.y + 32 && player.y > b.y) {
                 player.y = b.y + 32;
                 player.vy = 0;
                 handleBlockHit(b);
             }
             // Ë∏©Á£öÂ°ä
             else if (player.vy >= 0 && player.y + player.h >= b.y && player.y + player.h < b.y + 32) {
                 player.y = b.y - player.h;
                 player.vy = 0;
                 player.onGround = true;
             }
        }
    });
}

function handleBlockHit(b) {
    if (b.type === "question" && !b.used) {
        b.used = true;
        player.coins++;
        player.score += 100;
        spawnParticle(b.x + 16, b.y, "coin");
    } else if (b.type === "brick") {
        b.broken = true;
        spawnParticle(b.x + 16, b.y + 16, "rubble");
        player.score += 50;
    }
}

function spawnParticle(x, y, type, text) {
    if (type === "coin") {
        particles.push({x: x, y: y-32, vx: 0, vy: -8, life: 30, type: "coin_anim"});
    } else if (type === "rubble") {
        for(let i=0; i<4; i++) {
            particles.push({
                x: x, y: y, 
                vx: (Math.random()-0.5)*10, 
                vy: -5 - Math.random()*5, 
                life: 60, type: "rubble"
            });
        }
    } else if (type === "text") {
        particles.push({x:x, y:y, vx:0, vy:-2, life:40, type:"text", text:text});
    }
}

function draw() {
    ctx.fillStyle = "#5c94fc";
    ctx.fillRect(0, 0, c.width, c.height);

    // Èõ≤Êúµ
    ctx.save();
    clouds.forEach(cl => {
        let drawX = (cl.x - camX * 0.5 * cl.s); 
        // Á∞°ÂñÆÁöÑÂæ™Áí∞ËÉåÊôØ
        if(drawX < -100) drawX += 4000; 
        drawCloud(drawX, cl.y, cl.s);
    });
    ctx.restore();

    ctx.save();
    ctx.translate(-Math.floor(camX), 0);

    // Ë£ùÈ£æÂ±±ÊôØ
    ctx.fillStyle = "#1e8449";
    [300, 1500, 2800].forEach(mx => {
        ctx.beginPath();
        ctx.moveTo(mx, GROUND_Y);
        ctx.lineTo(mx + 100, GROUND_Y - 100);
        ctx.lineTo(mx + 200, GROUND_Y);
        ctx.fill();
    });

    // Âú∞ÊùøÁπ™Ë£Ω (ÈÅøÈñãÂùëÊ¥û)
    ctx.fillStyle = "#c84c0c";
    let floorStart = -100;
    let floorEnd = flag.x + 1000;
    
    // Áπ™Ë£ΩÂú∞ÊùøÊôÇË¶ÅÊâ£Èô§ÂùëÊ¥ûÈÉ®ÂàÜ
    // ÈÄôË£°Áî®Á∞°ÂñÆÁöÑÊñπÂºèÔºöÁï´ÊªøÁÑ∂ÂæåÊääÂùëÊ¥ûÂ°óÊàêÂ§©Á©∫Ëâ≤ÔºàÁ∞°ÂñÆÈÅÆÁΩ©ÔºâÊàñËÄÖ‰∏ÄÊÆµ‰∏ÄÊÆµÁï´
    // ÁÇ∫‰∫ÜÊïàËÉΩËàáÁ∞°ÂñÆÔºåÊàëÂÄë‰∏ÄÊÆµ‰∏ÄÊÆµÁï´
    let currentX = floorStart;
    pits.sort((a,b) => a.start - b.start);
    
    for(let pit of pits) {
        // Áï´ÂùëÊ¥ûÂâçÁöÑÂú∞
        if(pit.start > currentX) {
            drawFloorSegment(currentX, pit.start - currentX);
        }
        currentX = pit.end;
    }
    // Áï´Ââ©‰∏ãÁöÑÂú∞
    if(currentX < floorEnd) {
        drawFloorSegment(currentX, floorEnd - currentX);
    }

    // Á£öÂ°ä
    blocks.forEach(b => {
        if (b.broken) return;
        if (b.type === "question") {
            ctx.fillStyle = b.used ? "#b88a48" : "#f8b736";
            ctx.fillRect(b.x, b.y, 32, 32);
            ctx.fillStyle = "#9c6023";
            ctx.fillRect(b.x+2, b.y+2, 28, 28);
            ctx.fillStyle = b.used ? "#b88a48" : "#ffd06d";
            ctx.fillRect(b.x+4, b.y+4, 24, 24);
            if(!b.used) {
                ctx.fillStyle = "#ab7d2c";
                ctx.font = "bold 20px monospace";
                ctx.fillText("?", b.x+10, b.y+24);
            }
        } else {
            ctx.fillStyle = "#b55239";
            ctx.fillRect(b.x, b.y, 32, 32);
            ctx.fillStyle = "#8a3e2b";
            ctx.fillRect(b.x, b.y+15, 32, 2);
            ctx.fillRect(b.x+15, b.y, 2, 15);
            ctx.fillRect(b.x+8, b.y+17, 2, 15);
        }
    });

    // ÊóóÊ°ø
    ctx.fillStyle = "#2ecc71";
    ctx.fillRect(flag.x, flag.y, 4, 280);
    ctx.fillStyle = "black";
    ctx.beginPath(); ctx.arc(flag.x+2, flag.y, 8, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.moveTo(flag.x+4, flag.y+20);
    ctx.lineTo(flag.x+40, flag.y+35);
    ctx.lineTo(flag.x+4, flag.y+50);
    ctx.fill();
    drawCastle(flag.x + 80, GROUND_Y);

    // Êïµ‰∫∫
    enemies.forEach(e => { if (e.alive) drawGoomba(e.x, e.y); });

    // Á≤íÂ≠ê
    particles.forEach(p => {
        if(p.type === "coin_anim") {
            ctx.fillStyle = "gold"; ctx.beginPath(); ctx.arc(p.x, p.y, 10, 0, Math.PI*2); ctx.fill();
        } else if (p.type === "rubble") {
            ctx.fillStyle = "#b55239"; ctx.fillRect(p.x, p.y, 8, 8);
        } else if (p.type === "text") {
            ctx.fillStyle = "white"; ctx.font = "16px monospace"; ctx.fillText(p.text, p.x, p.y);
        }
    });

    // Áé©ÂÆ∂
    if (player.invincible % 4 < 2) drawToad(player.x, player.y, player.facingRight, player.crouch);

    ctx.restore();

    // UI
    ctx.fillStyle = "white";
    ctx.font = "bold 20px 'Microsoft JhengHei', monospace";
    ctx.fillText(`ÂàÜÊï∏: ${player.score}`, 20, 30);
    ctx.fillText(`ÈáëÂπ£: ${player.coins}`, 20, 55);
    ctx.fillText(`ÁîüÂëΩ: ${player.life}`, 20, 80);

    if (gameState === "won") drawOverlay("üéâ ÊÅ≠ÂñúÈÅéÈóúÔºÅ", "ÊåâË∑≥Ë∫çÈçµÈáçÊñ∞ÈñãÂßã");
    else if (gameState === "gameover") drawOverlay("üíÄ ÈÅäÊà≤ÁµêÊùü", "ÊåâË∑≥Ë∫çÈçµÂÜçË©¶‰∏ÄÊ¨°");
}

function drawFloorSegment(x, w) {
    ctx.fillStyle = "#c84c0c";
    ctx.fillRect(x, GROUND_Y, w, c.height - GROUND_Y);
    ctx.fillStyle = "#ffb692";
    ctx.fillRect(x, GROUND_Y, w, 4);
    
    // Á¥ãÁêÜ
    ctx.fillStyle = "rgba(0,0,0,0.1)";
    for(let i=0; i<w/32; i++) {
        let bx = x + i*32;
        ctx.fillRect(bx, GROUND_Y, 1, 32);
        ctx.fillRect(bx, GROUND_Y+31, 32, 1);
    }
}

function drawOverlay(title, sub) {
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(0,0,c.width,c.height);
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.font = "bold 40px 'Microsoft JhengHei', monospace";
    ctx.fillText(title, c.width/2, c.height/2 - 20);
    ctx.font = "bold 20px 'Microsoft JhengHei', monospace";
    ctx.fillText(sub, c.width/2, c.height/2 + 20);
    ctx.textAlign = "left";
}

// ========== ËßíËâ≤Áπ™Ë£ΩÂáΩÊï∏ (‰øùÊåÅ‰∏çËÆä) ==========
function drawToad(x, y, facingRight, crouch) {
    const yOff = crouch ? 16 : 0;
    ctx.fillStyle = "#1e49bc"; ctx.fillRect(x + 6, y + 24 + yOff, 20, 16 - yOff/2);
    ctx.fillStyle = "#ffffff"; ctx.fillRect(x + 6, y + 40, 20, 8);
    ctx.fillStyle = "#5c3310";
    if (facingRight) {
        if(Math.abs(player.vx)>0.1 && Math.floor(Date.now()/100)%2===0) ctx.fillRect(x+16, y+44, 12, 6);
        else { ctx.fillRect(x+4, y+44, 10, 4); ctx.fillRect(x+18, y+44, 10, 4); }
    } else {
        if(Math.abs(player.vx)>0.1 && Math.floor(Date.now()/100)%2===0) ctx.fillRect(x+4, y+44, 12, 6);
        else { ctx.fillRect(x+4, y+44, 10, 4); ctx.fillRect(x+18, y+44, 10, 4); }
    }
    const headY = y + yOff;
    ctx.fillStyle = "#ffffff"; ctx.beginPath(); ctx.arc(x + 16, headY + 14, 16, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "#e3001b"; ctx.beginPath(); ctx.arc(x + 16, headY + 6, 8, 0, Math.PI*2); ctx.fill();
    ctx.beginPath();
    if (facingRight) { ctx.arc(x+28, headY+16, 5, 0, Math.PI*2); ctx.arc(x+2, headY+16, 2, 0, Math.PI*2); }
    else { ctx.arc(x+4, headY+16, 5, 0, Math.PI*2); ctx.arc(x+30, headY+16, 2, 0, Math.PI*2); }
    ctx.fill();
    ctx.fillStyle = "#ffcece"; ctx.fillRect(x+8, headY+18, 16, 12);
    ctx.fillStyle = "black";
    if (facingRight) { ctx.fillRect(x+18, headY+20, 2, 6); ctx.fillRect(x+22, headY+20, 2, 6); }
    else { ctx.fillRect(x+8, headY+20, 2, 6); ctx.fillRect(x+12, headY+20, 2, 6); }
}

function drawGoomba(x, y) {
    ctx.fillStyle = "#8b4513";
    ctx.beginPath(); ctx.moveTo(x+4, y+32); ctx.lineTo(x+28, y+32); ctx.lineTo(x+32, y+10); ctx.lineTo(x+16, y); ctx.lineTo(x, y+10); ctx.fill();
    ctx.fillStyle = "black";
    let walk = Math.floor(Date.now() / 200) % 2;
    if(walk===0) { ctx.fillRect(x, y+28, 10, 4); ctx.fillRect(x+22, y+28, 10, 4); }
    else { ctx.fillRect(x+2, y+28, 10, 4); ctx.fillRect(x+20, y+28, 10, 4); }
    ctx.fillStyle = "#ffcece"; ctx.fillRect(x+8, y+18, 5, 5); ctx.fillRect(x+19, y+18, 5, 5);
    ctx.fillStyle = "black"; ctx.fillRect(x+10, y+20, 2, 3); ctx.fillRect(x+20, y+20, 2, 3);
}

function drawCloud(x, y, s) {
    ctx.fillStyle = "rgba(255,255,255,0.8)";
    ctx.beginPath(); ctx.arc(x, y, 20*s, 0, Math.PI*2); ctx.arc(x+15*s, y-10*s, 25*s, 0, Math.PI*2); ctx.arc(x+30*s, y, 20*s, 0, Math.PI*2); ctx.fill();
}

function drawCastle(x, y) {
    ctx.fillStyle = "#8a3e2b"; ctx.fillRect(x, y-64, 80, 64); ctx.fillRect(x+20, y-96, 40, 32);
    ctx.fillStyle = "black"; ctx.beginPath(); ctx.arc(x+40, y, 16, Math.PI, 0); ctx.fill();
}

function hit(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}
</script>
</body>
</html>