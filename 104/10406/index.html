<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>經典貪吃蛇 - 舒適挑戰版</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            /* 改為深色森林藍，減少眼睛負擔 */
            background-color: #121b28; 
            color: #e0e0e0; /* 柔和白 */
            font-family: 'Segoe UI', 'Courier New', monospace;
        }
        .info { text-align: center; margin-bottom: 10px; }
        h1 { margin: 10px 0 5px; font-size: 32px; letter-spacing: 5px; color: #ffffff; }
        .subtitle { font-size: 14px; margin-bottom: 15px; color: #8a99ad; }
        .score-container {
            display: flex; gap: 30px; font-size: 18px; margin-top: 10px;
            background: rgba(255,255,255,0.05);
            padding: 5px 20px;
            border-radius: 15px;
        }
        #msg { color: #f9d423; font-weight: bold; height: 24px; margin: 10px; font-size: 14px; }
        canvas {
            /* 邊框改為低飽和度的灰藍 */
            border: 8px solid #1e2a3a;
            background-color: #0b1118; /* 畫布背景稍微更深一點 */
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .controls { margin-top: 15px; color: #5c6b7e; font-size: 12px; }
        span#score { color: #f9d423; } /* 分數用舒服的亮黃 */
        span#highScore { color: #ff6b6b; } /* 最高分用柔和紅 */
    </style>
</head>
<body>

    <div class="info">
        <h1>經典貪吃蛇</h1>
        <div class="subtitle">每 100 分增加 2 個障礙 | 5 秒位置變換</div>
        <div class="score-container">
            <div>分數: <span id="score">0</span></div>
            <div>最高紀錄: <span id="highScore">0</span></div>
        </div>
        <div id="msg"></div>
    </div>

    <canvas id="gameCanvas" width="400" height="400"></canvas>

    <div class="controls">
        方向鍵控制移動
    </div>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const scoreElement = document.getElementById("score");
        const highScoreElement = document.getElementById("highScore");
        const msgElement = document.getElementById("msg");

        const gridSize = 20;
        const tileCount = canvas.width / gridSize;

        let score = 0;
        let highScore = localStorage.getItem("snakeHighScore") || 0;
        highScoreElement.innerHTML = highScore;

        let dx = 0; let dy = 0;
        let snake = [{x: 10, y: 10}];
        let food = {x: 5, y: 5};
        let obstacles = []; 
        let specialFood = null;
        let specialFoodTimer = null;
        let obstacleMoveTimer = null;
        
        let speed = 7;
        let changingDirection = false;
        let currentObstacleCount = 0;

        document.addEventListener("keydown", changeDirection);

        function main() {
            if (didGameEnd()) {
                handleGameOver();
                return;
            }

            changingDirection = false;
            setTimeout(function onTick() {
                clearCanvas();
                
                let targetCount = Math.floor(score / 100) * 2;
                if (targetCount > 0 && targetCount !== currentObstacleCount) {
                    currentObstacleCount = targetCount;
                    if (!obstacleMoveTimer) {
                        moveObstacles();
                    } else {
                        generateObstacles(currentObstacleCount);
                    }
                }

                drawObstacles();
                drawFood();
                drawSpecialFood();
                advanceSnake();
                drawSnake();
                
                if (!specialFood && Math.random() < 0.015 && (dx !== 0 || dy !== 0)) {
                    createSpecialFood();
                }
                
                main();
            }, 1000 / speed);
        }

        function moveObstacles() {
            if (currentObstacleCount === 0) return;
            generateObstacles(currentObstacleCount);
            showMsg("⚠️ 障礙物重組！");
            if (obstacleMoveTimer) clearTimeout(obstacleMoveTimer);
            obstacleMoveTimer = setTimeout(moveObstacles, 5000);
        }

        function generateObstacles(count) {
            obstacles = [];
            for (let i = 0; i < count; i++) {
                let obs;
                while (true) {
                    obs = {
                        x: Math.floor(Math.random() * tileCount),
                        y: Math.floor(Math.random() * tileCount)
                    };
                    const onSnake = snake.some(p => p.x === obs.x && p.y === obs.y);
                    const onFood = (obs.x === food.x && obs.y === food.y);
                    const nearHead = Math.abs(obs.x - snake[0].x) < 3 && Math.abs(obs.y - snake[0].y) < 3;
                    if (!onSnake && !onFood && !nearHead) break;
                }
                obstacles.push(obs);
            }
        }

        function drawObstacles() {
            ctx.fillStyle = "#ff5252"; // 柔和一點的珊瑚紅
            obstacles.forEach(obs => {
                ctx.fillRect(obs.x * gridSize + 1, obs.y * gridSize + 1, gridSize - 2, gridSize - 2);
            });
        }

        function advanceSnake() {
            const head = {x: snake[0].x + dx, y: snake[0].y + dy};
            if (dx === 0 && dy === 0) return;
            snake.unshift(head);
            if (snake[0].x === food.x && snake[0].y === food.y) {
                score += 10;
                updateScore();
                createFood();
                speed += 0.3;
            } else if (specialFood && snake[0].x === specialFood.x && snake[0].y === specialFood.y) {
                score += 30;
                updateScore();
                showMsg("✨ 黃金果實 +30");
                clearSpecialFood();
            } else {
                snake.pop();
            }
        }

        function didGameEnd() {
            for (let i = 4; i < snake.length; i++) {
                if (snake[i].x === snake[0].x && snake[i].y === snake[0].y) return true;
            }
            const hitWall = snake[0].x < 0 || snake[0].x > tileCount - 1 || snake[0].y < 0 || snake[0].y > tileCount - 1;
            const hitObstacle = obstacles.some(obs => obs.x === snake[0].x && obs.y === snake[0].y);
            return hitWall || hitObstacle;
        }

        function createFood() {
            food.x = Math.floor(Math.random() * tileCount);
            food.y = Math.floor(Math.random() * tileCount);
            if (snake.some(p => p.x === food.x && p.y === food.y) || obstacles.some(o => o.x === food.x && o.y === food.y)) createFood();
        }

        function createSpecialFood() {
            specialFood = { x: Math.floor(Math.random() * tileCount), y: Math.floor(Math.random() * tileCount) };
            if (snake.some(p => p.x === specialFood.x && p.y === specialFood.y) || obstacles.some(o => o.x === specialFood.x && o.y === specialFood.y)) {
                createSpecialFood(); return;
            }
            specialFoodTimer = setTimeout(() => { specialFood = null; }, 5000);
        }

        function clearSpecialFood() {
            specialFood = null;
            if (specialFoodTimer) clearTimeout(specialFoodTimer);
        }

        function drawSnake() {
            snake.forEach((part, index) => {
                // 蛇的顏色改為溫潤的青綠色系
                ctx.fillStyle = (index === 0) ? "#4ecdc4" : "#45b7af";
                ctx.fillRect(part.x * gridSize + 1, part.y * gridSize + 1, gridSize - 2, gridSize - 2);
            });
        }

        function drawFood() {
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.arc(food.x * gridSize + gridSize/2, food.y * gridSize + gridSize/2, gridSize/4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawSpecialFood() {
            if (specialFood) {
                const blink = Math.sin(Date.now() / 100) > 0;
                ctx.fillStyle = blink ? "#f9d423" : "rgba(249, 212, 35, 0.3)";
                ctx.fillRect(specialFood.x * gridSize, specialFood.y * gridSize, gridSize - 1, gridSize - 1);
            }
        }

        function clearCanvas() {
            ctx.fillStyle = "#0b1118";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function changeDirection(e) {
            if (changingDirection) return;
            changingDirection = true;
            const key = e.keyCode;
            if (key === 37 && dx !== 1) { dx = -1; dy = 0; }
            if (key === 38 && dy !== 1) { dx = 0; dy = -1; }
            if (key === 39 && dx !== -1) { dx = 1; dy = 0; }
            if (key === 40 && dy !== -1) { dx = 0; dy = 1; }
        }

        function updateScore() { scoreElement.innerHTML = score; }

        function showMsg(text) {
            msgElement.innerHTML = text;
            setTimeout(() => { if(msgElement.innerHTML === text) msgElement.innerHTML = ""; }, 2500);
        }

        function handleGameOver() {
            if (obstacleMoveTimer) clearTimeout(obstacleMoveTimer);
            obstacleMoveTimer = null;
            if (score > highScore) {
                localStorage.setItem("snakeHighScore", score);
                highScoreElement.innerHTML = score;
                alert("太強了！新紀錄: " + score);
            } else {
                alert("遊戲結束！本次得分: " + score);
            }
            resetGame();
        }

        function resetGame() {
            snake = [{x: 10, y: 10}];
            dx = 0; dy = 0; score = 0; speed = 7;
            obstacles = [];
            currentObstacleCount = 0;
            clearSpecialFood();
            updateScore();
            createFood();
            main();
        }

        createFood();
        main();
    </script>
</body>
</html>